{
  "name": "angoose",
  "version": "0.3.21",
  "description": "Angoose is a Remote Method Invocation module that comes with built-in mongoose/angular support. Now you can call server side module in browser just like you're in the server side!",
  "main": "lib/angoose",
  "scripts": {
    "test": "test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/tjworks/angoose.git"
  },
  "keywords": [
    "mongoose",
    "angular",
    "frontend",
    "model",
    "rpc",
    "rmi"
  ],
  "devDependencies": {
    "jasmine-node": "*",
    "grunt": "*",
    "grunt-contrib-concat": "*",
    "grunt-cli": "*",
    "grunt-contrib-jshint": "~0.7.2",
    "grunt-jasmine-node": "~0.1.0",
    "grunt-shell": "~0.6.1",
    "request": "*",
    "jasmine-custom-message": "~0.1.2",
    "node-mocks-http": "*",
    "grunt-contrib-watch": "~0.5.3",
    "mocha": "*"
  },
  "dependencies": {
    "underscore": "*",
    "mongoose": "3.8.3",
    "q": "*",
    "express": "*",
    "log4js": "*",
    "hooks": "~0.3.2",
    "shimmer": "~1.0.0",
    "traverse": "~0.6.6",
    "uglify-js": "*"
  },
  "author": {
    "name": "tjworks"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/tjworks/angoose/issues"
  },
  "readme": "## 1.What is it?\n================\n\nThe original motive for Angoose project is to do away with the dual model declarations(server and client side) if we are building a rich model based SPA application \nusing modern Javascript framework such as Angular and node.js.  With both front end and backend using Javascript, Angoose allows the server side models and services\nto be used in the client side as if they reside in the client side.\n\nAngoose depends on following frameworks and assumes you have basic familarities with them:\n\n* mongoose\n* express \n* angular (optional, for non-angular app, jQuery is required)\n\n\n#### Angoose Demo \n\nIf you would like to see Angoose in action, there is a demo site you can checkout. Go to:\n\n  https://github.com/tjworks/angoose-demo\n  \nAll you need to do is clone, npm install, and run. \n\n\n## 2. Get Started\n=================\n\nFollowing are the steps to integrate angoose with your existing project\n\n#### 1. npm install angoose\n\nOr add `angoose` to your dependencies in your package.json file.\n\n#### 2. configure angoose\nAssuming you already have an express server/app file, you just need to add following line to the app.js, after the app.configure() block:\n\n\t/** Typical express configuration */\n\tapp.configure(function() {\n\t\tapp.use(express.favicon());\n\t\tapp.use(express.bodyParser());\n\t\t...\n\t});\n\n\t/** Angoose bootstraping */\n    require(\"angoose\").init(app, {\n       'module-dirs':'/models',\n       'mongo-opts': 'localhost:27017/test',\n    });\n\nHere we assume your Mongoose model files are defined under `models` sub directory relative to the current dir where you start your app. \n\nRestart node.js \n\n\n#### 3. In your HTML file where angular library is included, add after angular script tag:\n\n     <script src=\"/angoose/angoose-client.js\"></script>\n     \n**NOTE**\n- The `/angoose/angoose-client.js` route will be handled by Angoose in the backend.\n- This file contains dynamic content based on your backend models. If you don't see updates in your client after changing backend, make sure no cache is in play. \n\n  \n\n#### 4. In your main angular app, add `angoose-client` to your app module dependencies. For example:\n\n    var myapp = angular.module('myapp', ['ngRoute',   'angoose.client']);\n\n#### 5. You are ready to go!\n\nAll the models defined in the `./models` folder will be auto-loaded and readily available for injection into your controller/service/directives etc, \njust delcare them in the function argument list(We're using `SampleUser` as example here): \n\n\tangular.module('myapp').controller('UserCtrl', function($scope, SampleUser) {\n\t\n\t\t/** There are two special methods provided by Angoose on Mongoose models that resemble Angular's \n\t\t *  $resource usage. `$get` will allow you to query for one model instance and `$query` for multiple\n\t\t *  values.  Calling `ModelClass.$get` will return immediately with a reference.\n\t\t * No callback is required, you can use `{{ sampleUser.firstname }}` in the template and \n\t\t * view will be automatically updated once the data arrives from server side.\n\t\t */ \n\t\t$scope.sampleUser = SampleUser.$get({'email':'xxx@yyy.com'} );  // get one user   \n\t\t$scope.disabledUsers = SampleUser.$query({'status': 'disabled'});   // get multiple users\n\t\t\n\t\t// create new instance and validations\t\t\n\t\tvar newUser = new SampleUser({\n\t\t\tfirstname:'xxx',\n\t\t\tlastname:'yyy',\n\t\t\temail:'xxx@asd',\n\t\t\tstatus:'active'\n\t\t});\n\t\t/** Call Mongoose model's save method. \n\t\t  * most of the methods will be async, even it's synchronous on the server side. \n\t\t  We're sending this call over the wire, after all */ \n\t\tnewUser.save(function(err, result){\n\t\t\tconsole.log(err);  // print out: 'email' is invalid\n\t\t});\n\n\t\tnewUser.email = 'test@google.com';\n\t\tnewUser.save(function(err, result){\n\t\t\t/** result is undefined since model.save() does not return value */\n\t\t\tconsole.log(newUser._id);  // print out: _id value\n\t\t\tnewUser.remove(); // remove this user from database\n\t\t}, function(err){\n\t\t\t/** if something went wrong */\n\t\t});\n\t});\n\t\n#### 6. If you are not using Angular\n\nIf you don't use angular, then you just need to include jQuery before the angoose-client.js. Then instead of step 4 & 5, you could simply do:\n\n \t\tvar SampleUser = angoose('SampleUser'); // lookup SampleUser module, this is same as angoose.module('SampleUser')\n \t\t// get one user\n\t\tvar sampleUser = SampleUser.findOne({'email':'xxx@yyy.com'}, function(err, user ){  \n\t\t\tsampleUser.firstname='Gaelyn';\n\t\t\tsampleUser.save(function(err){\n\t\t\t\tif(!err)  console.log(\"Success!\");\n\t\t\t\telse alert(\"Something went wrong: \" + err);\n\t\t\t});\n\t\t});    \n  \n## 3. How It Works?\n===================\n\nThe core of the Angoose is its Remote Method Invocation, or RMI, that bridges the gap between server side and front end. With this technique, the server side modules, such as\nMongoose models and custom defined service modules will be transparently made available to the client side. No need for REST api or route setup. Just call the modules as if they\nreside in the browser! See diagram below for a depiction of the RMI process. \n\n![Angoose Remote Method Invocation](https://www.lucidchart.com/publicSegments/view/52dbe203-1508-4b43-b6cb-5c020a00d361/image.png)\n\t \n\n## 4. Angoose Module\n==========================\n\nWah, you say, so I can use every NPM module out there in my front end? \n\nUnfortunately, no. Server side modules will not be automatically become avaialbe to the client side. And really you only want to make those modules with database/filesystem or other \nexternal IO operations available to the front end. For instance, Mongoose models or other database oriented service modules are good usa case of Angoose modules.\n\nOnly modules registered with Angoose will be exported to client side(hence the term `angoose module`). To register a module:\n\n- For Mongoose models, just make sure you set your `module.exports` to the return value of `mongoose.model()` call. \n- For other modules, call `angoose.module(name, func_or_object)` to register your service module. (angoose.service() is still supported and does same thing)\n\nAnd for either case, make sure Angoose knwo where to find your model files by using the `modelDir` configuration.\n\nThere are a couple of exmaples under `angoose/models` directory for reference. \n\n#### About Mongoose Models\n\nNote not all Mongoose model functionalities are exported yet. Following are a list of methods you can invoke on a Mongoose model from client side: \n\n**Instance methods**\n\n- save\n- remove \n\n**Static methods**\n\n- populate\n- find\n- findOne\n- findXXX (all other find methods)\n- update\n- remove\n- count\n- geoNear\n- geoSearch\n\n\n**NOTE** \n\nYou must supply a callback for most of these Mongoose model methods. Mongoose `query` is NOT supported in the client side yet. On the server side, Mongoose allows you to call\nthese methods without a callback function and it will return a `Qeury` instance to facilitate chaining. This may be changed in the future.  \n\nIn addition, there are two sugar methods designed for Angular. They similute the `$resource.get()` and `$resource.query()` in angular, in the way the method returns immediately with\na reference to the empty object/list. This way you don't need to use callback.  The empty object/list will be automatically populated(and view updated accordingly) once server side returns. Both of methods takes parameters similar\nto the Mongoose find() method.\n  \n- Model.$get() \tReturn a reference to one object\n- Model.$query()  Return a reference to an array of objects\n\n \n\n**Custom Methods on Mongoose Models**\n\nAny methods you defined in the Mongoose schema(whether static or instance) will be treated as remotable method and automatically exported to client.  \n\n\n## 5. Writting a Remotable Method\n=================================\n\nA few things to note when write a remotable method(methods invokable from client side).\n\n#### Handle Return Values and Errors in your Model or Service classes. \nWhen you define custom methods on your Model or Service class, you must adhere to following conventions:\n\n\n**Method has no async call**\n\nIf your method has no asynchronous call and returns the data directly at the end of the execution, no special handling is required. Just use normal `return xxx`.\n\nOr if there is no data to return, just skip the `return` statement.\n\nIf there is error during the method, you may return an error(avoid throw an error if possible):\n\n\t\tif(!require(\"fs\").existsSync(filename))\n\t\t\treturn new Error( \"File \"+ filename+\" does not exit\");\n\n**Method has async call** \n\nWhen you have async call in your method, you can no longer directly return the results or report an error if it occurred from callback handler.  In this case, you must declare\na callback function as your last function argument:\n \n\t/** MyService is an Angoose Service */\n\tvar MyService = function(){}\n\tMyService.geocoding = function(address, $callback){ \n\t\t/** note 2nd argument $callback. \n\t\tvar googleApi = require(\"google-geo-api\");\n\t\tgoogleApi.lookup( address, function( err, matchedAddresses){\n\t\t\tif(err)  $callback(err);\n\t\t\telse $callback(false, matchedAddresses[0]); /** $callback takes two arguments: err, result */\n\t\t});\n\t} \n\tmodule.exports = angoose.module(\"MyService\", MyService);\n\n\n#### Specifying Method Type\n\n**This is optional feature.**\n\nYou may use method annotation to indicate whether method should be exposed to the client side or only executed on the local/server side. Angoose recognizes following\nmethod types:\n\n- remote\n- local\n- portable\n\nMethod annotation is optional and all the methods you defined on your Model or Service (whether static or instance) are considered `remote` method, as long as you properly handled errors\nand return values accordingly. \n \nAngoose relies on the function name to indicate which type of method it is.   In general the function name is not required when you define the methods on Mongoose schema\nor on a Service class because the method would be assigned to a property of the container object. Example for a Mongoose model shcema:\n \n     new Schema({\n        methods: {\n            updateStatus: function(){ // notice function is annonymous\n                // body\n            }\n        }\n     })  \n  \n Angoose hence uses the unused function name as a way to annotate the method for the purpose of RMI. For instance, to indicate a method\n can be exported to the remote client, you would write the function like this:\n \n     {\n        methods: {\n            updateStatus: function remote(){ // function name is 'remote'\n                // body\n            }\n        }\n     }\n\nThe function name can be any of following:     \n  \n**remote**\n\nThis indicates the method should be exported to client side with a stub. Actual execution occurs on the server side. This is the default type.\n \n**portable**\n\nThis indicates the method should be \"ported\" to  client side. The actual execution will happen in client side only if\n it is invoked by client code. You can still invoke this method in the server side in which case the execution is done on the server side.\n \n An example of this usage is some helper method that only operates on the instance object and has no other dependencies. i.e., a method to concatenate the names\n to return a full name:\n \n     {\n       methods: {\n           getFullname: function portable{\n               return (this.firstname || \"\") + \" \" + (this.lastname || \"\");\n           }\n       }\n     } \n \n \n \n**local**\n\nThis indicates the method should NOT be exported. It can only be invoked on the server side, locally. \n    \n\n#### Angoose Context\n \nAngoose supports an execution context feature that allows you to access some contextual state from any part of the code,\nas long as the code execution was originated by Angoose RMI handler. This is made possible by  node domain.  \n\nFor each Angoose RMI invocation request, an unique Context object is created when Angoose starts handling. The context contains the request\nand response objects, as well as session and authenticated user info(TBD). The context can then be accessed by all the subsequent code paths, including in async callback functions.\n\nTo obtain the context, you may simple call:\n\n     angoose.getContext()\n \nSome of the common usage with the getContext() method:\n\n    angoose.getContext().getRequest():  returns the Express request object\n    angoose.getContext().getRequest().session Get Express request session.\n\n \n",
  "readmeFilename": "README.md",
  "_id": "angoose@0.3.21",
  "dist": {
    "shasum": "5fae26024c281d3ee08bafbebb6219df4b5f80bd"
  },
  "_from": "angoose@",
  "_resolved": "https://registry.npmjs.org/angoose/-/angoose-0.3.21.tgz"
}
